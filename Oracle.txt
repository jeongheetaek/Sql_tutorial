Oracle Setup Tutorial.

1. Pass - oracle
2. Port Num - remember 8080
3. Confirm the Setup - sqlplus system/oracle  - in Cmd

접속 이름 - system
사용자 이름 - system
비밀번호 - oracle

접속 이름 - scott
사용자 이름 - scott
비밀번호 - TIGER


//////////////IN SYSTEM/////////////////

-- USER 생성
CREATE USER scott IDENTIFIED BY tiger;
GRANT DBA TO scott;


/////////////////////////IN SCOTT//////////////

-- DDL
CREATE TABLE BEPT
( DEPTNO number(2) Constraint PK_DEPT Primary KEY, 
  DNAME VARCHAR2 (30),
  LOC VARCHAR2(20)
);

-- DML

INSERT INTO BEPT VALUES(10,'ACCOUNTING', '강남');
INSERT INTO BEPT(DEPTNO, DNAME) VALUES(20,'RESEARCH'); -- 두개의 컬럼에 넣으려면 두개의 인덱스를 먼저 설정해준다.
INSERT INTO BEPT(DEPTNO, DNAME) VALUES(30,'TEST');
INSERT INTO BEPT(DEPTNO, DNAME) VALUES(40,'TEST3');

UPDATE BEPT
SET LOC = '당산'
WHERE DEPTNO = 30;

DELETE BEPT WHERE DEPTNO = 40;



CREATE TABLE ex_type
  (c CHAR(10), 
  v VARCHAR2(10)
  );
  
  INSERT INTO ex_type Values('sql', 'sql');
  SELECT * FROM ex_type
  WHERE c = 'sql';
  
  SELECT * FROM ex_type
  WHERE c=v; -- CHAR 와 VARCHAR 에서 텍스트가 들어갔을 때 메모리 할당의 차이를 확인함

SELECT ROWNUM, ROWID, DNAME -- 내용값을 포함하고있다 (내용을 지정하지 않아도 이미 지정되어있음
FROM DEPT;

SELECT STUDNO, NAME, DEPTNO, WEIGHT
FROM STUDENT
--WHERE GRADE = '1';
WHERE WEIGHT <= 70;

SELECT STUDNO, NAME, DEPTNO, WEIGHT, GRADE
FROM STUDENT
WHERE GRADE = '1'
AND WEIGHT >= 70;

SELECT STUDNO, NAME, DEPTNO, WEIGHT, GRADE
FROM STUDENT
WHERE WEIGHT BETWEEN 50 AND 70;

SELECT STUDNO, NAME, WEIGHT, GRADE, DEPTNO
FROM STUDENT
WHERE DEPTNO IN (102,201); -- OR와 같은 결과

SELECT STUDNO, WEIGHT, GRADE, NAME
FROM STUDENT
WHERE NAME LIKE '김%';

SELECT STUDNO, WEIGHT, GRADE, NAME
FROM STUDENT0
WHERE NAME LIKE '김_영';

SELECT EMPNO, SAL, COMM, SAL+COMM
FROM EMP;

--NVL 은 NULL 일경우 B로 바꿔주라는 것 NVL (A,B) A가 NULL 이면 B가 된다.
SELECT NVL(NULL, 'B') FROM DUAL; -- DUAL은 임시테이블이다. 테이블없이 작업하기 위해서 사용

SELECT NVL2('C1', 'A','B') FROM DUAL; -- NVL2 (K,A,B) K가 NULL이면 B, NULL 아니면 A

SELECT NAME, POSITION, COMM
FROM PROFESSOR
WHERE COMM IS NULL;

CREATE TABLE STUDY_HEAVY
AS SELECT *
FROM STUDENT
WHERE WEIGHT >= 70 AND GRADE = 1;

CREATE TABLE STUD_101
AS SELECT *
FROM STUDENT
WHERE DEPTNO=101 AND GRADE= 1;


SELECT STUDNO, NAME
FROM STUDY_HEAVY
UNION-- 위 아래의 컬럼의 갯수가 같아야 한다. (SELECT에서 검색하고자 한 쿼리들) 중복값을 제거하고 나옴 BUT UNION ALL로 하면 중복제거 없이 나옴
SELECT STUDNO, NAME
FROM STUD_101;


SELECT STUDNO, NAME
FROM STUDY_HEAVY
INTERSECT --교집합만 나오도록 설정
SELECT STUDNO, NAME
FROM STUD_101;

SELECT NAME , GRADE , TEL
FROM STUDENT
ORDER BY NAME;

SELECT NAME , GRADE , TEL
FROM STUDENT
ORDER BY NAME DESC;

SELECT ENAME, JOB, SAL, DEPTNO
FROM EMP 
ORDER BY DEPTNO, SAL DESC; -- 두가지 정렬이 있을때는 AND가 아닌 , 로 처리할 수 있다.

SELECT ENAME, DEPTNO
FROM EMP
WHERE DEPTNO IN(10,30)
ORDER BY ENAME;

SELECT ENAME, HIREDATE
FROM EMP
WHERE HIREDATE LIKE '82%'; -- 일치하는지 파악하는건 LIKE (산술연산에 해당하는거) = 는 단순 일치에서만 사용

SELECT ENAME, SAL, COMM
FROM EMP
WHERE COMM IS NOT NULL AND COMM > 0 -- 문제에서 보너스를 받는 ! 이라는 전제조건이 있다. (전제조건 확인)
ORDER BY SAL DESC, COMM DESC;

SELECT ENAME, SAL, COMM, DEPTNO
FROM EMP
WHERE COMM >= (SAL*0.2) AND DEPTNO LIKE 30; -- LIKE 는 문자열과 숫자또한 가능함 숫자도 문자열로 받을 수 있음

SELECT ENAME, SAL, COMM, DEPTNO
FROM EMP
WHERE COMM >= (SAL*0.2) AND TO_CHAR(DEPTNO) LIKE '30%'; -- LIKE 문자열로만 받는다면


SELECT COUNT (COMM)
FROM PROFESSOR
WHERE DEPTNO = 101;

SELECT COUNT (*)
FROM PROFESSOR
WHERE DEPTNO = 101;

SELECT AVG(WEIGHT), SUM(WEIGHT)
FROM STUDENT
WHERE DEPTNO = 101;

SELECT MAX(HEIGHT), MIN(HEIGHT)
FROM STUDENT
WHERE DEPTNO = 101;


-- DEPTNO 별로 평균값이 만들어져 나왔다. (그룹별로 값을 설정할 수 있다.)
SELECT AVG(SAL), DEPTNO
FROM PROFESSOR
GROUP BY DEPTNO;

SELECT DEPTNO, MIN(SAL), MAX(SAL)
FROM PROFESSOR
GROUP BY DEPTNO
ORDER BY MAX(SAL) DESC;

SELECT DEPTNO, POSITION, MIN(SAL), MAX(SAL)
FROM PROFESSOR
GROUP BY DEPTNO, POSITION -- GROUP BY 절은 SELECT에서 그룹 설정할 때 같은 그룹순서를 지정해줘야 한다.
ORDER BY MAX(SAL) DESC;


SELECT DEPTNO, GRADE, COUNT(*), AVG(WEIGHT) --COUNT의 대상은 어떤게 되는게 맞는거지? NULL값이 발생할 수 있기 때문에 *로 묶어서 줘야한다.
FROM STUDENT
GROUP BY DEPTNO, GRADE -- WHERE 을 먼저 실행해야한다 WHERE DEPTNO = 101 하게되면 101을 찾고 그 다음 그룹을 나눠서 SELECT 뒤의 값을 실행한다.
ORDER BY DEPTNO;

SELECT DEPTNO, GRADE, COUNT(*), AVG(WEIGHT) --COUNT의 대상은 어떤게 되는게 맞는거지? NULL값이 발생할 수 있기 때문에 *로 묶어서 줘야한다.
FROM STUDENT
WHERE DEPTNO = 101 -- 문법적 순서 WHERE -> GROUP BY 
GROUP BY DEPTNO, GRADE -- WHERE 을 먼저 실행해야한다 WHERE DEPTNO = 101 하게되면 101을 찾고 그 다음 그룹을 나눠서 SELECT 뒤의 값을 실행한다.
ORDER BY DEPTNO;

SELECT DEPTNO, GRADE, COUNT(*), ROUND(AVG(WEIGHT)) --소수점 (ROUND)
FROM STUDENT
GROUP BY DEPTNO, GRADE
ORDER BY DEPTNO;

SELECT DEPTNO, POSITION, COUNT(*)
FROM PROFESSOR
GROUP BY ROLLUP(DEPTNO, POSITION); --부서별과 직위별 모두 케이스를 나눠놓은것

SELECT DEPTNO, POSITION, COUNT(*)
FROM PROFESSOR
GROUP BY CUBE (DEPTNO, POSITION); 

SELECT GRADE, 
  COUNT(*), ROUND(AVG(HEIGHT)) AVG_HEIGHT, 
  ROUND(AVG(WEIGHT)) AVG_WEIGHT
FROM STUDENT
GROUP BY GRADE
HAVING COUNT(*) > 4 -- COUNT 된 값이 4명이상이 된 GRADE 한해서 전달
ORDER BY AVG_HEIGHT DESC;

--1
DESC SALGRADE

--2
SELECT * FROM SALGRADE;

--3
SELECT * FROM TAB;

--4
SELECT EMPNO, ENAME, SAL, JOB, HIREDATE
FROM EMP;

--5
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL < 2000;

--6 X
SELECT EMPNO, ENAME, SAL, JOB, HIREDATE
FROM EMP
WHERE HIREDATE > '81/02/01'; -- 내부적으로 자동으로 DATA 형태로 바꿔줌

--7
SELECT ENAME, JOB
FROM EMP
WHERE JOB LIKE 'SALESMAN';

--8
SELECT ENAME, J
FROM EMP
WHERE JOB NOT LIKE 'CLERK';

--9
SELECT EMPNO, ENAME
FROM EMP
WHERE ENAME LIKE 'K%';

--10 이름, 급여, 연봉 이름, 급여 YEARSAL (
SELECT ENAME, SAL, COMM, ((SAL+COMM)*12) AS YEARSAL
FROM EMP
WHERE COMM IS NOT NULL;

SELECT ENAME, SAL,(SAL+NVL(COMM, 0)) * 12 AS YEARSAL
FROM EMP;

--10 - 정답
SELECT ENAME, SAL,(SAL+NVL(COMM, 0)) * 12 AS YEARSAL
FROM EMP;

--11
SELECT ENAME, JOB
FROM EMP
WHERE JOB IN('MANAGER','SALESMAN');

--12
SELECT ENAME, SAL
FROM EMP
WHERE SAL BETWEEN 1500 AND 3000;













































